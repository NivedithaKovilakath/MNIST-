# -*- coding: utf-8 -*-
"""mnist_KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QsX7Pvkog5RZtPptC9z-LkdFWh_8WZjc
"""

import numpy as np
import tensorflow as tf
import keras
import math
import operator

#importing MNIST data set

mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()

#Forming arrays for the input and output data
'''
x_train=np.array(x_train)
x_test=np.array(x_test)

y_train=np.array(y_train)
y_test=np.array(y_test)

'''

#to flatten the arrays

l=len(x_train)

x_train=x_train.reshape(l,-1)
y_train=y_train.reshape(l,-1)

m=len(x_test)
x_test=x_test.reshape(m,-1)
y_test=y_test.reshape(m,-1)

y_train=y_train.flatten()
y_test=y_test.flatten()

#slice

x_train=x_train[:100]
x_test=x_test[:100]
y_train=y_train[:100]
y_test=y_test[:100]

#Calculating Euclidean distance

def euclidean_distance(row1, row2):
  distance=0.0
  for i in range(len(row1)):
    distance += pow((row1[i] - row2[i]), 2)
  return math.sqrt(distance)

#to get the nearest neighbours

def get_neighbours(train_set, test_row, k):
  distance=[]
  for i in range(len(train_set)):
    d=euclidean_distance(test_row, train_set[i])
    distance.append([train_set[i],i,d])
  distance.sort(key=lambda elem:elem[2])
  neighbours=[]
  for x in range(k):
    neighbours.append([distance[x][0],distance[x][1]])
  return neighbours

#make predictions with neighbours

def get_response(neighbours):
  classvotes={}
  for i in range(len(neighbours)):
    response=y_train[neighbours[i][1]]
    if response in classvotes:
      classvotes[response] +=1
    else:
      classvotes[response]=1

  sortedvotes=sorted(classvotes.items(),key=operator.itemgetter(1),reverse=True)
  return sortedvotes[0][0]

#to print accuracy

def get_accuracy(y_test, predictions):
  correct=0
  for x in range(len(y_test)):
    if y_test[x] == predictions[x]:
      correct +=1
  
  return (correct/float(len(y_test)))*100

def main():
  predictions=[]
  k=5
  for x in range(len(x_test)):
    neighbours=get_neighbours(x_train, x_test[x],k)
    result=get_response(neighbours)
    predictions.append(result)
    #print("PREDICTED: "+ str(result)+ "ACTUAL: "+ str(y_test[x]))
  
  accuracy=get_accuracy(y_test,predictions)
  print("ACCURACY: "+ str(accuracy)+'%')

main()